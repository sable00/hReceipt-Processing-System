# -*- coding: utf-8 -*-
"""
Simulates the Agentic Invoice Processing workflow based on the provided flowchart.

This script defines functions representing each step of the process:
- Invoice Labelling
- Ruleset Data lookup
- Reasoning LLM (placeholder)
- Action LLM (placeholder)
- Tools interaction

It demonstrates the flow of data (text, labels, rules, chain of thought)
between these components.
"""

import json # Using json for potential structured data handling

# --- 1. Invoice Data (Sample Input) ---
# In a real scenario, this would come from an OCR process or digital invoice file.
raw_invoice_data = {
    "id": "INV-12345",
    "vendor": "Supplier Corp",
    "amount": 1500.75,
    "items": [
        {"description": "Widget A", "quantity": 10, "price": 100.00},
        {"description": "Service B", "quantity": 1, "price": 500.75}
    ],
    "full_text": """
    INVOICE
    Supplier Corp
    123 Supply St.
    Invoice #INV-12345
    Date: 2025-04-20

    Bill To:
    Client Ltd.
    456 Client Ave.

    Item         Qty   Price   Total
    Widget A     10    100.00  1000.00
    Service B    1     500.75   500.75
    ----------------------------------
    Total:                 1500.75
    """
}

# --- 2. Invoice Labelling ---
def invoice_labelling(invoice_data):
    """
    Simulates extracting text and assigning a label to the invoice.

    Args:
        invoice_data (dict): Raw data representing the invoice.

    Returns:
        tuple: A tuple containing:
            - str: The extracted text data only.
            - str: The assigned label (e.g., 'standard', 'dispute', 'urgent').
    """
    print("[Step 1] Performing Invoice Labelling...")
    # Simple text extraction (in reality, more complex)
    text_data = invoice_data.get("full_text", "")

    # Simple labelling logic (placeholder)
    label = "standard" # Default label
    if invoice_data.get("amount", 0) > 1000:
        label = "high_value"
    if "urgent" in text_data.lower():
         label = "urgent"

    print(f"  - Extracted Text (snippet): {text_data[:50]}...")
    print(f"  - Assigned Label: {label}")
    return text_data, label

# --- 3. Ruleset Data ---
# Represents the database/store of rules keyed by labels.
RULESET_DATA = {
    "standard": [
        "Rule S1: Verify vendor details.",
        "Rule S2: Check for duplicate invoice ID.",
        "Rule S3: Match items with purchase order (if available)."
    ],
    "high_value": [
        "Rule H1: Requires manager approval.",
        "Rule H2: Perform enhanced fraud check.",
        "Rule S1: Verify vendor details.", # Inherits standard rule
        "Rule S3: Match items with purchase order (if available)."
    ],
    "urgent": [
        "Rule U1: Expedite payment processing.",
        "Rule U2: Notify accounts payable immediately.",
        "Rule S2: Check for duplicate invoice ID."
    ],
    "default": [
        "Rule D1: Basic validation check."
    ]
}

def get_filtered_rules(label, ruleset):
    """
    Retrieves rules from the ruleset based on the assigned label.

    Args:
        label (str): The label assigned by the invoice_labelling step.
        ruleset (dict): The dictionary containing all rules.

    Returns:
        list: A list of filtered rules applicable to the label.
    """
    print(f"[Step 2] Retrieving Filtered Rules for Label: {label}...")
    filtered_rules = ruleset.get(label, ruleset.get("default", []))
    print(f"  - Found {len(filtered_rules)} rules.")
    # print(f"  - Rules: {filtered_rules}") # Uncomment to see rules
    return filtered_rules

# --- 4. Reasoning LLM (Placeholder) ---
def reasoning_llm(filtered_rules, text_data):
    """
    Simulates the Reasoning LLM processing rules and text to generate a plan.

    Args:
        filtered_rules (list): Rules applicable to the invoice.
        text_data (str): Text extracted from the invoice.

    Returns:
        str: A synthetic chain of thought (plan) generated by the LLM.
    """
    print("[Step 3] Running Reasoning LLM...")
    print("  - Input: Filtered Rules, Text Data")

    # --- Placeholder Logic ---
    # In reality, this involves complex NLP and reasoning.
    # Here, we just combine the inputs into a structured thought process.
    chain_of_thought = "Synthetic Chain of Thought:\n"
    chain_of_thought += "1. Analyze invoice text data.\n"
    chain_of_thought += f"2. Apply the following {len(filtered_rules)} rules:\n"
    for i, rule in enumerate(filtered_rules):
        chain_of_thought += f"   - Rule {i+1}: {rule}\n"
    chain_of_thought += "3. Based on rules and text, determine necessary actions.\n"
    chain_of_thought += "4. Formulate plan for Action LLM."
    # --- End Placeholder ---

    print("  - Output: Synthetic Chain of Thought (Generated)")
    # print(f"  - CoT: {chain_of_thought}") # Uncomment to see CoT
    return chain_of_thought

# --- 5. Tools Information ---
# Represents information about available tools the Action LLM can use.
TOOLS_INFO = {
    "vendor_lookup": {
        "description": "Looks up vendor details in the database.",
        "parameters": ["vendor_name"]
    },
    "po_matching": {
        "description": "Matches invoice items against a Purchase Order.",
        "parameters": ["invoice_id", "po_number"] # PO number might need extraction
    },
    "approval_request": {
        "description": "Sends an approval request to a manager.",
        "parameters": ["invoice_id", "amount", "manager_email"]
    },
    "payment_scheduler": {
        "description": "Schedules the invoice for payment.",
        "parameters": ["invoice_id", "payment_date"]
    }
}

def get_tools_info():
    """Provides information about available tools."""
    print("[Step 4a] Getting Tools Info...")
    # In a real system, this might dynamically discover tools.
    print(f"  - Available Tools: {list(TOOLS_INFO.keys())}")
    return TOOLS_INFO

# --- 6. Action LLM (Placeholder) ---
def action_llm(chain_of_thought, text_data, tools_info):
    """
    Simulates the Action LLM using the plan, text, and tools to decide actions.

    Args:
        chain_of_thought (str): The plan from the Reasoning LLM.
        text_data (str): Text extracted from the invoice.
        tools_info (dict): Information about available tools.

    Returns:
        dict: A dictionary representing the final action or result.
    """
    print("[Step 4b] Running Action LLM...")
    print("  - Input: Chain of Thought, Text Data, Tools Info")

    # --- Placeholder Logic ---
    # This would involve the LLM interpreting the plan and deciding
    # which tools to call or what final action to take.
    action_result = {"status": "pending", "actions_taken": [], "summary": ""}

    # Example: Simple logic based on CoT keywords
    if "Requires manager approval" in chain_of_thought:
        action_result["actions_taken"].append({
            "tool_used": "approval_request",
            "parameters": {"invoice_id": raw_invoice_data["id"], "amount": raw_invoice_data["amount"], "manager_email": "manager@example.com"},
            "status": "simulated_success"
        })
        action_result["summary"] = "High value invoice requires approval. Request sent."
        action_result["status"] = "awaiting_approval"
    elif "Expedite payment processing" in chain_of_thought:
         action_result["actions_taken"].append({
            "tool_used": "payment_scheduler",
            "parameters": {"invoice_id": raw_invoice_data["id"], "payment_date": "ASAP"},
            "status": "simulated_success"
         })
         action_result["summary"] = "Urgent invoice scheduled for expedited payment."
         action_result["status"] = "payment_scheduled"
    else:
        # Default action for standard invoices
        action_result["actions_taken"].append({
            "tool_used": "po_matching", # Simulate attempting PO match
            "parameters": {"invoice_id": raw_invoice_data["id"], "po_number": "PO-987"}, # Example PO
            "status": "simulated_success_no_match_found" # Example outcome
        })
        action_result["actions_taken"].append({
            "tool_used": "payment_scheduler",
            "parameters": {"invoice_id": raw_invoice_data["id"], "payment_date": "standard_terms"},
            "status": "simulated_success"
         })
        action_result["summary"] = "Standard invoice processed. PO match attempted. Scheduled for payment."
        action_result["status"] = "payment_scheduled"
    # --- End Placeholder ---

    print(f"  - Output: Action Result: {action_result['status']}")
    return action_result

# --- 7. Main Workflow Orchestration ---
def process_invoice(invoice_data):
    """
    Orchestrates the entire invoice processing workflow.

    Args:
        invoice_data (dict): The raw invoice data.

    Returns:
        dict: The final result from the Action LLM.
    """
    print(f"\n--- Processing Invoice: {invoice_data.get('id', 'N/A')} ---")

    # Step 1: Labelling and Text Extraction
    text_data, label = invoice_labelling(invoice_data)

    # Step 2: Get Filtered Rules
    filtered_rules = get_filtered_rules(label, RULESET_DATA)

    # Step 3: Reasoning LLM
    chain_of_thought = reasoning_llm(filtered_rules, text_data)

    # Step 4a: Get Tools Info
    tools_info = get_tools_info()

    # Step 4b: Action LLM
    final_result = action_llm(chain_of_thought, text_data, tools_info)

    print(f"--- Invoice Processing Complete: {invoice_data.get('id', 'N/A')} ---")
    print(f"Final Status: {final_result.get('status')}")
    print(f"Summary: {final_result.get('summary')}")
    print("Actions:")
    for action in final_result.get("actions_taken", []):
        print(f"  - Tool: {action['tool_used']}, Params: {action['parameters']}, Status: {action['status']}")

    return final_result

# --- Execute the workflow ---
if __name__ == "__main__":
    result = process_invoice(raw_invoice_data)
    print("\n--- Final Result ---")
    # Pretty print the final result dictionary
    print(json.dumps(result, indent=2))

    # Example with a different invoice (modify raw_invoice_data for testing)
    # raw_invoice_data_urgent = raw_invoice_data.copy()
    # raw_invoice_data_urgent["full_text"] += "\nNOTE: Payment is urgent!"
    # raw_invoice_data_urgent["id"] = "INV-67890"
    # process_invoice(raw_invoice_data_urgent)
